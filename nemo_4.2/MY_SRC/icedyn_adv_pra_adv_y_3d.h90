   SUBROUTINE adv_y( pdt, pvt, pcrh, pe1e2, psm, ps0, psx, psxx, psy, psyy, psxy )
      !!---------------------------------------------------------------------
      !!                **  routine adv_y  **
      !!
      !! ** purpose :   Computes and adds the advection trend to sea-ice
      !!                variable on y axis
      !!---------------------------------------------------------------------
      REAL(wp)                  , INTENT(in   ) ::   pdt                ! time step
      REAL(wp), DIMENSION(:,:)  , INTENT(in   ) ::   pvt                ! j-direction ice velocity at V-point [m/s]
      REAL(wp)                  , INTENT(in   ) ::   pcrh               ! call adv_x then adv_y (=1) or the opposite (=0)
      REAL(wp), DIMENSION(:,:)  , INTENT(in   ) ::   pe1e2
      REAL(wp), DIMENSION(:,:,:), INTENT(inout) ::   psm                ! area
      REAL(wp), DIMENSION(:,:,:), INTENT(inout) ::   ps0                ! field to be advected
      REAL(wp), DIMENSION(:,:,:), INTENT(inout) ::   psx , psy          ! 1st moments
      REAL(wp), DIMENSION(:,:,:), INTENT(inout) ::   psxx, psyy, psxy   ! 2nd moments
      !!
      INTEGER  ::   ji, jj, jl, jcat                     ! dummy loop indices
      INTEGER  ::   ki0                                  ! dummy loop indices
      REAL(wp) ::   zs1max, zslpmax, ztemp               ! temporary scalars
      REAL(wp) ::   zs1new, zalf , zalfq , zbt           !    -         -
      REAL(wp) ::   zs2new, zalf1, zalf1q, zbt1          !    -         -
      REAL(wp) ::   zpsm, zps0
      REAL(wp) ::   zpsx, zpsy, zpsxx, zpsyy, zpsxy
      REAL(wp) ::   zmask, zV
      REAL(wp), DIMENSION(jpi,jpj) ::   zf0, zfx , zfy , zbet   ! 2D workspace
      REAL(wp), DIMENSION(jpi,jpj) ::   zfm, zfxx, zfyy, zfxy   !  -      -
      REAL(wp), DIMENSION(jpi,jpj) ::   zalg, zalg1, zalg1q     !  -      -
      !---------------------------------------------------------------------
      ! in order to avoid lbc_lnk (communications):
      !    ji loop must be 1:jpi   if adv_y is called first
      !                and 2:jpi-1 if adv_y is called second
      ki0 = NINT(pcrh)
      !
      jcat = SIZE( ps0 , 3 )   ! size of input arrays
      !
      DO jl = 1, jcat   ! loop on categories
      !
      ! Limitation of moments.
      DO_2D( ki0, ki0, 1, 1 )
            !! => whole domain for `jj` !
            !
            zmask = tmask(ji,jj,1)
            zV    = pvt(ji,jj)
            !
            zpsm  = psm (ji,jj,jl) ! optimization
            zps0  = ps0 (ji,jj,jl)
            zpsx  = psx (ji,jj,jl)
            zpsxx = psxx(ji,jj,jl)
            zpsy  = psy (ji,jj,jl)
            zpsyy = psyy(ji,jj,jl)
            zpsxy = psxy(ji,jj,jl)
            !
            !  Initialize volumes of boxes (=area if adv_y first called, =psm otherwise)
            zpsm = MAX( pcrh * e1e2t(ji,jj)*1.E-6_wp + ( 1.0 - pcrh ) * zpsm , epsi20  )
            !
            zslpmax = MAX( 0._wp, zps0 )
            zs1max  = 1.5 * zslpmax
            zs1new  = MIN( zs1max, MAX( -zs1max, zpsy ) )
            zs2new  = MIN( ( 2.0 * zslpmax - 0.3334 * ABS( zs1new ) ), MAX( ABS( zs1new )-zslpmax, zpsyy ) )
            rswitch = ( 1.0 - MAX( 0._wp, SIGN( 1._wp, -zslpmax) ) ) * zmask   ! Case of empty boxes & Apply mask
            !
            zps0  = zslpmax
            zpsx  = zpsx   * rswitch
            zpsxx = zpsxx  * rswitch
            zpsy  = zs1new * rswitch
            zpsyy = zs2new * rswitch
            zpsxy = MIN( zslpmax, MAX( -zslpmax, zpsxy ) ) * rswitch

            !  Calculate fluxes and moments between boxes j<-->j+1
            !                                !  Flux from j to j+1 WHEN v GT 0
            zbet(ji,jj)  =  MAX( 0._wp, SIGN( 1._wp, zV ) )
            zalf         =  MAX( 0._wp, zV ) * pdt / zpsm
            zalfq        =  zalf * zalf
            zalf1        =  1.0 - zalf
            zalf1q       =  zalf1 * zalf1
            !
            zfm (ji,jj)  =  zalf  * zpsm
            zf0 (ji,jj)  =  zalf  * ( zps0 + zalf1 * ( zpsy  + (zalf1-zalf) * zpsyy ) )
            zfy (ji,jj)  =  zalfq *( zpsy + 3.0*zalf1*zpsyy )
            zfyy(ji,jj)  =  zalf  * zalfq * zpsyy
            zfx (ji,jj)  =  zalf  * ( zpsx + zalf1 * zpsxy )
            zfxy(ji,jj)  =  zalfq * zpsxy
            zfxx(ji,jj)  =  zalf  * zpsxx
            !
            !                                !  Readjust moments remaining in the box.
            zpsm   =  zpsm  - zfm(ji,jj)
            zps0   =  zps0  - zf0(ji,jj)
            zpsy   =  zalf1q * ( zpsy -3.0 * zalf * zpsyy )
            zpsyy  =  zalf1 * zalf1q * zpsyy
            zpsx   =  zpsx  - zfx(ji,jj)
            zpsxx  =  zpsxx - zfxx(ji,jj)
            zpsxy  =  zalf1q * zpsxy
            !
            psm (ji,jj,jl) = zpsm ! optimization
            ps0 (ji,jj,jl) = zps0
            psx (ji,jj,jl) = zpsx
            psxx(ji,jj,jl) = zpsxx
            psy (ji,jj,jl) = zpsy
            psyy(ji,jj,jl) = zpsyy
            psxy(ji,jj,jl) = zpsxy
      END_2D
      !
      DO_2D( ki0, ki0, 1, 0 )
            !! Only `jj+1` needed
            !! => [0:jpj-1] for `jj` !
            zV = pvt(ji,jj)
            !                                !  Flux from j+1 to j when v LT 0.
            zalf          = MAX( 0._wp, -zV ) * pdt / psm(ji,jj+1,jl)
            zalg  (ji,jj) = zalf
            zalfq         = zalf * zalf
            zalf1         = 1.0 - zalf
            zalg1 (ji,jj) = zalf1
            zalf1q        = zalf1 * zalf1
            zalg1q(ji,jj) = zalf1q
            !
            zfm   (ji,jj) = zfm (ji,jj) + zalf  *    psm (ji,jj+1,jl)
            zf0   (ji,jj) = zf0 (ji,jj) + zalf  * (  ps0 (ji,jj+1,jl) &
               &            - zalf1 * (psy(ji,jj+1,jl) - (zalf1 - zalf ) * psyy(ji,jj+1,jl) ) )
            zfy   (ji,jj) = zfy (ji,jj) + zalfq * (  psy (ji,jj+1,jl) - 3.0 * zalf1 * psyy(ji,jj+1,jl) )
            zfyy  (ji,jj) = zfyy(ji,jj) + zalf  *    psyy(ji,jj+1,jl) * zalfq
            zfx   (ji,jj) = zfx (ji,jj) + zalf  * (  psx (ji,jj+1,jl) - zalf1 * psxy(ji,jj+1,jl) )
            zfxy  (ji,jj) = zfxy(ji,jj) + zalfq *    psxy(ji,jj+1,jl)
            zfxx  (ji,jj) = zfxx(ji,jj) + zalf  *    psxx(ji,jj+1,jl)
      END_2D

      DO_2D( ki0, ki0, 0, 1 )
            !! Only `jj-1` needed
            !! => [2:jpj] for `jj` !
            !                                !  Readjust moments remaining in the box.
            zbt  =         zbet(ji,jj-1)
            zbt1 = ( 1.0 - zbet(ji,jj-1) )
            !
            zpsm  = psm (ji,jj,jl) ! optimization
            zps0  = ps0 (ji,jj,jl)
            zpsx  = psx (ji,jj,jl)
            zpsxx = psxx(ji,jj,jl)
            zpsy  = psy (ji,jj,jl)
            zpsyy = psyy(ji,jj,jl)
            zpsxy = psxy(ji,jj,jl)
            !
            zpsm  = zbt * zpsm + zbt1 * ( zpsm - zfm(ji,jj-1) )
            zps0  = zbt * zps0 + zbt1 * ( zps0 - zf0(ji,jj-1) )
            zpsy  = zalg1q(ji,jj-1) * ( zpsy + 3.0 * zalg(ji,jj-1) * zpsyy )
            zpsyy = zalg1 (ji,jj-1) * zalg1q(ji,jj-1) * zpsyy
            zpsx  = zbt * zpsx  + zbt1 * ( zpsx  - zfx (ji,jj-1) )
            zpsxx = zbt * zpsxx + zbt1 * ( zpsxx - zfxx(ji,jj-1) )
            zpsxy = zalg1q(ji,jj-1) * zpsxy

            !   Put the temporary moments into appropriate neighboring boxes.
            !                                !   Flux from j to j+1 IF v GT 0.
            zbt   =       zbet(ji,jj-1)
            zbt1  = 1.0 - zbet(ji,jj-1)
            zpsm  = zbt * ( zpsm + zfm(ji,jj-1) ) + zbt1 * zpsm
            zalf  = zbt * zfm(ji,jj-1) / zpsm
            zalf1 = 1.0 - zalf
            ztemp = zalf * zps0 - zalf1 * zf0(ji,jj-1)
            !
            zps0  =   zbt  * ( zps0 + zf0(ji,jj-1) ) + zbt1 * zps0
            zpsy  =   zbt  * ( zalf * zfy(ji,jj-1) + zalf1 * zpsy + 3.0 * ztemp )  &
               &             + zbt1 * zpsy
            zpsyy =   zbt  * ( zalf * zalf * zfyy(ji,jj-1) + zalf1 * zalf1 * zpsyy                           &
               &             + 5.0 * ( zalf * zalf1 * ( zpsy - zfy(ji,jj-1) ) - ( zalf1 - zalf ) * ztemp ) ) &
               &             + zbt1 * zpsyy
            zpsxy =   zbt  * ( zalf * zfxy(ji,jj-1) + zalf1 * zpsxy             &
               &             + 3.0 * (- zalf1 * zfx(ji,jj-1) + zalf * zpsx ) )  &
               &             + zbt1 * zpsxy
            zpsx  =   zbt * ( zpsx  + zfx (ji,jj-1) ) + zbt1 * zpsx
            zpsxx =   zbt * ( zpsxx + zfxx(ji,jj-1) ) + zbt1 * zpsxx

            !                                !  Flux from j+1 to j IF v LT 0.
            zbt   =       zbet(ji,jj)
            zbt1  = 1.0 - zbet(ji,jj)
            zpsm  = zbt * zpsm + zbt1 * ( zpsm + zfm(ji,jj) )
            zalf  = zbt1 * zfm(ji,jj) / zpsm
            zalf1 = 1.0 - zalf
            ztemp = - zalf * zps0 + zalf1 * zf0(ji,jj)
            !
            zps0  = zbt * zps0  + zbt1 * (  zps0 + zf0(ji,jj) )
            zpsy  = zbt * zpsy  + zbt1 * (  zalf * zfy(ji,jj) + zalf1 * zpsy + 3.0 * ztemp )
            zpsyy = zbt * zpsyy + zbt1 * (  zalf * zalf * zfyy(ji,jj) + zalf1 * zalf1 * zpsyy &
               &                         + 5.0 * ( zalf * zalf1 * ( - zpsy + zfy(ji,jj) )     &
               &                         + ( zalf1 - zalf ) * ztemp ) )
            zpsxy = zbt * zpsxy + zbt1 * (  zalf * zfxy(ji,jj) + zalf1 * zpsxy  &
               &                         + 3.0 * ( zalf1 * zfx(ji,jj) - zalf * zpsx ) )
            zpsx  = zbt * zpsx  + zbt1 * ( zpsx  + zfx (ji,jj) )
            zpsxx = zbt * zpsxx + zbt1 * ( zpsxx + zfxx(ji,jj) )
            !
            psm (ji,jj,jl) = zpsm ! optimization
            ps0 (ji,jj,jl) = zps0
            psx (ji,jj,jl) = zpsx
            psxx(ji,jj,jl) = zpsxx
            psy (ji,jj,jl) = zpsy
            psyy(ji,jj,jl) = zpsyy
            psxy(ji,jj,jl) = zpsxy
            !
      END_2D
      !
      END DO !DO jl = 1, jcat
      !
   END SUBROUTINE adv_y
